// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/seizadi/test/pkg/pb/service.proto

// Generated with protoc-gen-gorm version: v0.18.0
// Anticipating compatibility with atlas-app-toolkit version: v0.19.0

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	github.com/seizadi/test/pkg/pb/service.proto

It has these top-level messages:
	VersionResponse
	Host
	CreateHostRequest
	CreateHostResponse
	ReadHostRequest
	ReadHostResponse
	UpdateHostRequest
	UpdateHostResponse
	DeleteHostRequest
	DeleteHostResponse
	ListHostRequest
	ListHostsResponse
	Application
	CreateApplicationRequest
	CreateApplicationResponse
	ReadApplicationRequest
	ReadApplicationResponse
	UpdateApplicationRequest
	UpdateApplicationResponse
	DeleteApplicationRequest
	DeleteApplicationResponse
	ListApplicationRequest
	ListApplicationsResponse
	Event
	CreateEventRequest
	CreateEventResponse
	ReadEventRequest
	ReadEventResponse
	UpdateEventRequest
	UpdateEventResponse
	DeleteEventRequest
	DeleteEventResponse
	ListEventRequest
	ListEventsResponse
	Ami
	CreateAmiRequest
	CreateAmiResponse
	ReadAmiRequest
	ReadAmiResponse
	UpdateAmiRequest
	UpdateAmiResponse
	DeleteAmiRequest
	DeleteAmiResponse
	ListAmiRequest
	ListAmisResponse
*/
package pb

import context "context"
import time "time"

import auth1 "github.com/infobloxopen/atlas-app-toolkit/auth"
import errors1 "github.com/infobloxopen/protoc-gen-gorm/errors"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
import ptypes1 "github.com/golang/protobuf/ptypes"
import query1 "github.com/infobloxopen/atlas-app-toolkit/query"
import resource1 "github.com/infobloxopen/atlas-app-toolkit/gorm/resource"

import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/protobuf/field_mask"
import _ "github.com/golang/protobuf/ptypes/timestamp"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/lyft/protoc-gen-validate/validate"
import _ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
import _ "github.com/infobloxopen/atlas-app-toolkit/query"
import _ "github.com/infobloxopen/atlas-app-toolkit/rpc/resource"
import _ "github.com/infobloxopen/protoc-gen-atlas-query-validate/options"
import _ "github.com/infobloxopen/protoc-gen-atlas-validate/options"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type HostORM struct {
	AccountID   string
	AmiId       interface{}
	Description string
	Id          int64 `gorm:"type:serial;primary_key"`
	Name        string
	VpcId       interface{}
}

// TableName overrides the default tablename generated by GORM
func (HostORM) TableName() string {
	return "hosts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Host) ToORM(ctx context.Context) (HostORM, error) {
	to := HostORM{}
	var err error
	if prehook, ok := interface{}(m).(HostWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Host{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	if v, err := resource1.Decode(nil, m.VpcId); err != nil {
		return to, err
	} else if v != nil {
		to.VpcId = v
	}
	if v, err := resource1.Decode(nil, m.AmiId); err != nil {
		return to, err
	} else if v != nil {
		to.AmiId = v
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(HostWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *HostORM) ToPB(ctx context.Context) (Host, error) {
	to := Host{}
	var err error
	if prehook, ok := interface{}(m).(HostWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Host{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	if v, err := resource1.Encode(nil, m.VpcId); err != nil {
		return to, err
	} else {
		to.VpcId = v
	}
	if v, err := resource1.Encode(nil, m.AmiId); err != nil {
		return to, err
	} else {
		to.AmiId = v
	}
	if posthook, ok := interface{}(m).(HostWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Host the arg will be the target, the caller the one being converted from

// HostBeforeToORM called before default ToORM code
type HostWithBeforeToORM interface {
	BeforeToORM(context.Context, *HostORM) error
}

// HostAfterToORM called after default ToORM code
type HostWithAfterToORM interface {
	AfterToORM(context.Context, *HostORM) error
}

// HostBeforeToPB called before default ToPB code
type HostWithBeforeToPB interface {
	BeforeToPB(context.Context, *Host) error
}

// HostAfterToPB called after default ToPB code
type HostWithAfterToPB interface {
	AfterToPB(context.Context, *Host) error
}

type ApplicationORM struct {
	AccountID   string
	Description string
	Id          int64 `gorm:"type:serial;primary_key"`
	Name        string
}

// TableName overrides the default tablename generated by GORM
func (ApplicationORM) TableName() string {
	return "applications"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Application) ToORM(ctx context.Context) (ApplicationORM, error) {
	to := ApplicationORM{}
	var err error
	if prehook, ok := interface{}(m).(ApplicationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Application{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ApplicationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ApplicationORM) ToPB(ctx context.Context) (Application, error) {
	to := Application{}
	var err error
	if prehook, ok := interface{}(m).(ApplicationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Application{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	if posthook, ok := interface{}(m).(ApplicationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Application the arg will be the target, the caller the one being converted from

// ApplicationBeforeToORM called before default ToORM code
type ApplicationWithBeforeToORM interface {
	BeforeToORM(context.Context, *ApplicationORM) error
}

// ApplicationAfterToORM called after default ToORM code
type ApplicationWithAfterToORM interface {
	AfterToORM(context.Context, *ApplicationORM) error
}

// ApplicationBeforeToPB called before default ToPB code
type ApplicationWithBeforeToPB interface {
	BeforeToPB(context.Context, *Application) error
}

// ApplicationAfterToPB called after default ToPB code
type ApplicationWithAfterToPB interface {
	AfterToPB(context.Context, *Application) error
}

type EventORM struct {
	AccountID     string
	AmiId         interface{}
	ApplicationId interface{}
	Description   string
	EventTime     *time.Time
	HostId        interface{}
	Id            int64 `gorm:"type:serial;primary_key"`
	Name          string
}

// TableName overrides the default tablename generated by GORM
func (EventORM) TableName() string {
	return "events"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Event) ToORM(ctx context.Context) (EventORM, error) {
	to := EventORM{}
	var err error
	if prehook, ok := interface{}(m).(EventWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Event{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	if m.EventTime != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.EventTime); err != nil {
			return to, err
		}
		to.EventTime = &t
	}
	if v, err := resource1.Decode(nil, m.HostId); err != nil {
		return to, err
	} else if v != nil {
		to.HostId = v
	}
	if v, err := resource1.Decode(nil, m.AmiId); err != nil {
		return to, err
	} else if v != nil {
		to.AmiId = v
	}
	if v, err := resource1.Decode(nil, m.ApplicationId); err != nil {
		return to, err
	} else if v != nil {
		to.ApplicationId = v
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(EventWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EventORM) ToPB(ctx context.Context) (Event, error) {
	to := Event{}
	var err error
	if prehook, ok := interface{}(m).(EventWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Event{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	if m.EventTime != nil {
		if to.EventTime, err = ptypes1.TimestampProto(*m.EventTime); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(nil, m.HostId); err != nil {
		return to, err
	} else {
		to.HostId = v
	}
	if v, err := resource1.Encode(nil, m.AmiId); err != nil {
		return to, err
	} else {
		to.AmiId = v
	}
	if v, err := resource1.Encode(nil, m.ApplicationId); err != nil {
		return to, err
	} else {
		to.ApplicationId = v
	}
	if posthook, ok := interface{}(m).(EventWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Event the arg will be the target, the caller the one being converted from

// EventBeforeToORM called before default ToORM code
type EventWithBeforeToORM interface {
	BeforeToORM(context.Context, *EventORM) error
}

// EventAfterToORM called after default ToORM code
type EventWithAfterToORM interface {
	AfterToORM(context.Context, *EventORM) error
}

// EventBeforeToPB called before default ToPB code
type EventWithBeforeToPB interface {
	BeforeToPB(context.Context, *Event) error
}

// EventAfterToPB called after default ToPB code
type EventWithAfterToPB interface {
	AfterToPB(context.Context, *Event) error
}

type AmiORM struct {
	AccountID   string
	Description string
	Id          int64 `gorm:"type:serial;primary_key"`
	Name        string
}

// TableName overrides the default tablename generated by GORM
func (AmiORM) TableName() string {
	return "amis"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Ami) ToORM(ctx context.Context) (AmiORM, error) {
	to := AmiORM{}
	var err error
	if prehook, ok := interface{}(m).(AmiWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Ami{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(AmiWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AmiORM) ToPB(ctx context.Context) (Ami, error) {
	to := Ami{}
	var err error
	if prehook, ok := interface{}(m).(AmiWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Ami{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	if posthook, ok := interface{}(m).(AmiWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Ami the arg will be the target, the caller the one being converted from

// AmiBeforeToORM called before default ToORM code
type AmiWithBeforeToORM interface {
	BeforeToORM(context.Context, *AmiORM) error
}

// AmiAfterToORM called after default ToORM code
type AmiWithAfterToORM interface {
	AfterToORM(context.Context, *AmiORM) error
}

// AmiBeforeToPB called before default ToPB code
type AmiWithBeforeToPB interface {
	BeforeToPB(context.Context, *Ami) error
}

// AmiAfterToPB called after default ToPB code
type AmiWithAfterToPB interface {
	AfterToPB(context.Context, *Ami) error
}

// DefaultCreateHost executes a basic gorm create call
func DefaultCreateHost(ctx context.Context, in *Host, db *gorm1.DB) (*Host, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type HostORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type HostORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadHost executes a basic gorm read call
func DefaultReadHost(ctx context.Context, in *Host, db *gorm1.DB, fs *query1.FieldSelection) (*Host, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &HostORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := HostORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(HostORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type HostORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type HostORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type HostORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteHost(ctx context.Context, in *Host, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&HostORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type HostORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type HostORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteHostSet(ctx context.Context, in []*Host, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&HostORM{})).(HostORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&HostORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&HostORM{})).(HostORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type HostORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Host, *gorm1.DB) (*gorm1.DB, error)
}
type HostORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Host, *gorm1.DB) error
}

// DefaultStrictUpdateHost clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateHost(ctx context.Context, in *Host, db *gorm1.DB) (*Host, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateHost")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &HostORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type HostORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type HostORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type HostORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchHost executes a basic gorm update call with patch behavior
func DefaultPatchHost(ctx context.Context, in *Host, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Host, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Host
	var err error
	if hook, ok := interface{}(&pbObj).(HostWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadHost(ctx, &Host{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(HostWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskHost(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(HostWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateHost(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(HostWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type HostWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Host, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type HostWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Host, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type HostWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Host, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type HostWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Host, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetHost executes a bulk gorm update call with patch behavior
func DefaultPatchSetHost(ctx context.Context, objects []*Host, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Host, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Host, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchHost(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskHost patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskHost(ctx context.Context, patchee *Host, patcher *Host, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Host, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"VpcId" {
			patchee.VpcId = patcher.VpcId
			continue
		}
		if f == prefix+"AmiId" {
			patchee.AmiId = patcher.AmiId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListHost executes a gorm list call
func DefaultListHost(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Host, error) {
	in := Host{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &HostORM{}, &Host{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []HostORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Host{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type HostORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type HostORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type HostORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]HostORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateApplication executes a basic gorm create call
func DefaultCreateApplication(ctx context.Context, in *Application, db *gorm1.DB) (*Application, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ApplicationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadApplication executes a basic gorm read call
func DefaultReadApplication(ctx context.Context, in *Application, db *gorm1.DB, fs *query1.FieldSelection) (*Application, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &ApplicationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := ApplicationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ApplicationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ApplicationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ApplicationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ApplicationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteApplication(ctx context.Context, in *Application, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ApplicationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ApplicationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteApplicationSet(ctx context.Context, in []*Application, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ApplicationORM{})).(ApplicationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ApplicationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ApplicationORM{})).(ApplicationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ApplicationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Application, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Application, *gorm1.DB) error
}

// DefaultStrictUpdateApplication clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateApplication(ctx context.Context, in *Application, db *gorm1.DB) (*Application, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateApplication")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ApplicationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ApplicationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchApplication executes a basic gorm update call with patch behavior
func DefaultPatchApplication(ctx context.Context, in *Application, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Application, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Application
	var err error
	if hook, ok := interface{}(&pbObj).(ApplicationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadApplication(ctx, &Application{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ApplicationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskApplication(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ApplicationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateApplication(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ApplicationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ApplicationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Application, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Application, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Application, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Application, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetApplication executes a bulk gorm update call with patch behavior
func DefaultPatchSetApplication(ctx context.Context, objects []*Application, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Application, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Application, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchApplication(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskApplication patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskApplication(ctx context.Context, patchee *Application, patcher *Application, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Application, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListApplication executes a gorm list call
func DefaultListApplication(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Application, error) {
	in := Application{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ApplicationORM{}, &Application{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ApplicationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Application{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ApplicationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ApplicationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ApplicationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ApplicationORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateEvent executes a basic gorm create call
func DefaultCreateEvent(ctx context.Context, in *Event, db *gorm1.DB) (*Event, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EventORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EventORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EventORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EventORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadEvent executes a basic gorm read call
func DefaultReadEvent(ctx context.Context, in *Event, db *gorm1.DB, fs *query1.FieldSelection) (*Event, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EventORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &EventORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EventORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := EventORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EventORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EventORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type EventORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type EventORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteEvent(ctx context.Context, in *Event, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EventORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EventORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EventORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type EventORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EventORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteEventSet(ctx context.Context, in []*Event, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&EventORM{})).(EventORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&EventORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&EventORM{})).(EventORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EventORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Event, *gorm1.DB) (*gorm1.DB, error)
}
type EventORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Event, *gorm1.DB) error
}

// DefaultStrictUpdateEvent clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEvent(ctx context.Context, in *Event, db *gorm1.DB) (*Event, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEvent")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &EventORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(EventORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(EventORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EventORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type EventORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EventORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EventORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchEvent executes a basic gorm update call with patch behavior
func DefaultPatchEvent(ctx context.Context, in *Event, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Event, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Event
	var err error
	if hook, ok := interface{}(&pbObj).(EventWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadEvent(ctx, &Event{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(EventWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEvent(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EventWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEvent(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EventWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EventWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Event, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EventWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Event, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EventWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Event, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EventWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Event, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetEvent executes a bulk gorm update call with patch behavior
func DefaultPatchSetEvent(ctx context.Context, objects []*Event, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Event, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Event, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchEvent(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskEvent patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEvent(ctx context.Context, patchee *Event, patcher *Event, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Event, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"EventTime" {
			patchee.EventTime = patcher.EventTime
			continue
		}
		if f == prefix+"HostId" {
			patchee.HostId = patcher.HostId
			continue
		}
		if f == prefix+"AmiId" {
			patchee.AmiId = patcher.AmiId
			continue
		}
		if f == prefix+"ApplicationId" {
			patchee.ApplicationId = patcher.ApplicationId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEvent executes a gorm list call
func DefaultListEvent(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Event, error) {
	in := Event{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EventORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &EventORM{}, &Event{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EventORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []EventORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EventORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Event{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EventORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type EventORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type EventORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]EventORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateAmi executes a basic gorm create call
func DefaultCreateAmi(ctx context.Context, in *Ami, db *gorm1.DB) (*Ami, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AmiORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AmiORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AmiORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AmiORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadAmi executes a basic gorm read call
func DefaultReadAmi(ctx context.Context, in *Ami, db *gorm1.DB, fs *query1.FieldSelection) (*Ami, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AmiORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &AmiORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AmiORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := AmiORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AmiORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AmiORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type AmiORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type AmiORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteAmi(ctx context.Context, in *Ami, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AmiORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AmiORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AmiORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AmiORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AmiORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteAmiSet(ctx context.Context, in []*Ami, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AmiORM{})).(AmiORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&AmiORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AmiORM{})).(AmiORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AmiORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Ami, *gorm1.DB) (*gorm1.DB, error)
}
type AmiORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Ami, *gorm1.DB) error
}

// DefaultStrictUpdateAmi clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAmi(ctx context.Context, in *Ami, db *gorm1.DB) (*Ami, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAmi")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &AmiORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AmiORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AmiORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AmiORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AmiORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AmiORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AmiORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchAmi executes a basic gorm update call with patch behavior
func DefaultPatchAmi(ctx context.Context, in *Ami, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Ami, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Ami
	var err error
	if hook, ok := interface{}(&pbObj).(AmiWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAmi(ctx, &Ami{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AmiWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAmi(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AmiWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAmi(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AmiWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AmiWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Ami, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AmiWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Ami, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AmiWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Ami, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AmiWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Ami, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetAmi executes a bulk gorm update call with patch behavior
func DefaultPatchSetAmi(ctx context.Context, objects []*Ami, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Ami, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Ami, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAmi(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAmi patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAmi(ctx context.Context, patchee *Ami, patcher *Ami, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Ami, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAmi executes a gorm list call
func DefaultListAmi(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Ami, error) {
	in := Ami{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AmiORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &AmiORM{}, &Ami{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AmiORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AmiORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AmiORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Ami{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AmiORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type AmiORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type AmiORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]AmiORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}
type HostsDefaultServer struct {
}

// Create ...
func (m *HostsDefaultServer) Create(ctx context.Context, in *CreateHostRequest) (*CreateHostResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(HostsHostWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateHost(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateHostResponse{Result: res}
	if custom, ok := interface{}(in).(HostsHostWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// HostsHostWithBeforeCreate called before DefaultCreateHost in the default Create handler
type HostsHostWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// HostsHostWithAfterCreate called before DefaultCreateHost in the default Create handler
type HostsHostWithAfterCreate interface {
	AfterCreate(context.Context, *CreateHostResponse, *gorm1.DB) error
}

// Read ...
func (m *HostsDefaultServer) Read(ctx context.Context, in *ReadHostRequest) (*ReadHostResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(HostsHostWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadHost(ctx, &Host{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadHostResponse{Result: res}
	if custom, ok := interface{}(in).(HostsHostWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// HostsHostWithBeforeRead called before DefaultReadHost in the default Read handler
type HostsHostWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// HostsHostWithAfterRead called before DefaultReadHost in the default Read handler
type HostsHostWithAfterRead interface {
	AfterRead(context.Context, *ReadHostResponse, *gorm1.DB) error
}

// Update ...
func (m *HostsDefaultServer) Update(ctx context.Context, in *UpdateHostRequest) (*UpdateHostResponse, error) {
	var err error
	var res *Host
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(HostsHostWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateHost(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchHost(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateHostResponse{Result: res}
	if custom, ok := interface{}(in).(HostsHostWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// HostsHostWithBeforeUpdate called before DefaultUpdateHost in the default Update handler
type HostsHostWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// HostsHostWithAfterUpdate called before DefaultUpdateHost in the default Update handler
type HostsHostWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateHostResponse, *gorm1.DB) error
}

// Delete ...
func (m *HostsDefaultServer) Delete(ctx context.Context, in *DeleteHostRequest) (*DeleteHostResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(HostsHostWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteHost(ctx, &Host{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteHostResponse{}
	if custom, ok := interface{}(in).(HostsHostWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// HostsHostWithBeforeDelete called before DefaultDeleteHost in the default Delete handler
type HostsHostWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// HostsHostWithAfterDelete called before DefaultDeleteHost in the default Delete handler
type HostsHostWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteHostResponse, *gorm1.DB) error
}

// List ...
func (m *HostsDefaultServer) List(ctx context.Context, in *ListHostRequest) (*ListHostsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(HostsHostWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListHost(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListHostsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(HostsHostWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// HostsHostWithBeforeList called before DefaultListHost in the default List handler
type HostsHostWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// HostsHostWithAfterList called before DefaultListHost in the default List handler
type HostsHostWithAfterList interface {
	AfterList(context.Context, *ListHostsResponse, *gorm1.DB) error
}
type ApplicationsDefaultServer struct {
}

// Create ...
func (m *ApplicationsDefaultServer) Create(ctx context.Context, in *CreateApplicationRequest) (*CreateApplicationResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateApplication(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateApplicationResponse{Result: res}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationsApplicationWithBeforeCreate called before DefaultCreateApplication in the default Create handler
type ApplicationsApplicationWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationsApplicationWithAfterCreate called before DefaultCreateApplication in the default Create handler
type ApplicationsApplicationWithAfterCreate interface {
	AfterCreate(context.Context, *CreateApplicationResponse, *gorm1.DB) error
}

// Read ...
func (m *ApplicationsDefaultServer) Read(ctx context.Context, in *ReadApplicationRequest) (*ReadApplicationResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadApplication(ctx, &Application{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadApplicationResponse{Result: res}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationsApplicationWithBeforeRead called before DefaultReadApplication in the default Read handler
type ApplicationsApplicationWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationsApplicationWithAfterRead called before DefaultReadApplication in the default Read handler
type ApplicationsApplicationWithAfterRead interface {
	AfterRead(context.Context, *ReadApplicationResponse, *gorm1.DB) error
}

// Update ...
func (m *ApplicationsDefaultServer) Update(ctx context.Context, in *UpdateApplicationRequest) (*UpdateApplicationResponse, error) {
	var err error
	var res *Application
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateApplication(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchApplication(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateApplicationResponse{Result: res}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationsApplicationWithBeforeUpdate called before DefaultUpdateApplication in the default Update handler
type ApplicationsApplicationWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationsApplicationWithAfterUpdate called before DefaultUpdateApplication in the default Update handler
type ApplicationsApplicationWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateApplicationResponse, *gorm1.DB) error
}

// Delete ...
func (m *ApplicationsDefaultServer) Delete(ctx context.Context, in *DeleteApplicationRequest) (*DeleteApplicationResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteApplication(ctx, &Application{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteApplicationResponse{}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationsApplicationWithBeforeDelete called before DefaultDeleteApplication in the default Delete handler
type ApplicationsApplicationWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationsApplicationWithAfterDelete called before DefaultDeleteApplication in the default Delete handler
type ApplicationsApplicationWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteApplicationResponse, *gorm1.DB) error
}

// List ...
func (m *ApplicationsDefaultServer) List(ctx context.Context, in *ListApplicationRequest) (*ListApplicationsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListApplication(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListApplicationsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationsApplicationWithBeforeList called before DefaultListApplication in the default List handler
type ApplicationsApplicationWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationsApplicationWithAfterList called before DefaultListApplication in the default List handler
type ApplicationsApplicationWithAfterList interface {
	AfterList(context.Context, *ListApplicationsResponse, *gorm1.DB) error
}
type EventsDefaultServer struct {
}

// Create ...
func (m *EventsDefaultServer) Create(ctx context.Context, in *CreateEventRequest) (*CreateEventResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(EventsEventWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateEvent(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateEventResponse{Result: res}
	if custom, ok := interface{}(in).(EventsEventWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// EventsEventWithBeforeCreate called before DefaultCreateEvent in the default Create handler
type EventsEventWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// EventsEventWithAfterCreate called before DefaultCreateEvent in the default Create handler
type EventsEventWithAfterCreate interface {
	AfterCreate(context.Context, *CreateEventResponse, *gorm1.DB) error
}

// Read ...
func (m *EventsDefaultServer) Read(ctx context.Context, in *ReadEventRequest) (*ReadEventResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(EventsEventWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadEvent(ctx, &Event{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadEventResponse{Result: res}
	if custom, ok := interface{}(in).(EventsEventWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// EventsEventWithBeforeRead called before DefaultReadEvent in the default Read handler
type EventsEventWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// EventsEventWithAfterRead called before DefaultReadEvent in the default Read handler
type EventsEventWithAfterRead interface {
	AfterRead(context.Context, *ReadEventResponse, *gorm1.DB) error
}

// Update ...
func (m *EventsDefaultServer) Update(ctx context.Context, in *UpdateEventRequest) (*UpdateEventResponse, error) {
	var err error
	var res *Event
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(EventsEventWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateEvent(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchEvent(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateEventResponse{Result: res}
	if custom, ok := interface{}(in).(EventsEventWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// EventsEventWithBeforeUpdate called before DefaultUpdateEvent in the default Update handler
type EventsEventWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// EventsEventWithAfterUpdate called before DefaultUpdateEvent in the default Update handler
type EventsEventWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateEventResponse, *gorm1.DB) error
}

// Delete ...
func (m *EventsDefaultServer) Delete(ctx context.Context, in *DeleteEventRequest) (*DeleteEventResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(EventsEventWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteEvent(ctx, &Event{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteEventResponse{}
	if custom, ok := interface{}(in).(EventsEventWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// EventsEventWithBeforeDelete called before DefaultDeleteEvent in the default Delete handler
type EventsEventWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// EventsEventWithAfterDelete called before DefaultDeleteEvent in the default Delete handler
type EventsEventWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteEventResponse, *gorm1.DB) error
}

// List ...
func (m *EventsDefaultServer) List(ctx context.Context, in *ListEventRequest) (*ListEventsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(EventsEventWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListEvent(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListEventsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(EventsEventWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// EventsEventWithBeforeList called before DefaultListEvent in the default List handler
type EventsEventWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// EventsEventWithAfterList called before DefaultListEvent in the default List handler
type EventsEventWithAfterList interface {
	AfterList(context.Context, *ListEventsResponse, *gorm1.DB) error
}
type AmisDefaultServer struct {
}

// Create ...
func (m *AmisDefaultServer) Create(ctx context.Context, in *CreateAmiRequest) (*CreateAmiResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AmisAmiWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateAmi(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateAmiResponse{Result: res}
	if custom, ok := interface{}(in).(AmisAmiWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AmisAmiWithBeforeCreate called before DefaultCreateAmi in the default Create handler
type AmisAmiWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AmisAmiWithAfterCreate called before DefaultCreateAmi in the default Create handler
type AmisAmiWithAfterCreate interface {
	AfterCreate(context.Context, *CreateAmiResponse, *gorm1.DB) error
}

// Read ...
func (m *AmisDefaultServer) Read(ctx context.Context, in *ReadAmiRequest) (*ReadAmiResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AmisAmiWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadAmi(ctx, &Ami{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadAmiResponse{Result: res}
	if custom, ok := interface{}(in).(AmisAmiWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AmisAmiWithBeforeRead called before DefaultReadAmi in the default Read handler
type AmisAmiWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AmisAmiWithAfterRead called before DefaultReadAmi in the default Read handler
type AmisAmiWithAfterRead interface {
	AfterRead(context.Context, *ReadAmiResponse, *gorm1.DB) error
}

// Update ...
func (m *AmisDefaultServer) Update(ctx context.Context, in *UpdateAmiRequest) (*UpdateAmiResponse, error) {
	var err error
	var res *Ami
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AmisAmiWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateAmi(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchAmi(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateAmiResponse{Result: res}
	if custom, ok := interface{}(in).(AmisAmiWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AmisAmiWithBeforeUpdate called before DefaultUpdateAmi in the default Update handler
type AmisAmiWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AmisAmiWithAfterUpdate called before DefaultUpdateAmi in the default Update handler
type AmisAmiWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateAmiResponse, *gorm1.DB) error
}

// Delete ...
func (m *AmisDefaultServer) Delete(ctx context.Context, in *DeleteAmiRequest) (*DeleteAmiResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AmisAmiWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteAmi(ctx, &Ami{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteAmiResponse{}
	if custom, ok := interface{}(in).(AmisAmiWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AmisAmiWithBeforeDelete called before DefaultDeleteAmi in the default Delete handler
type AmisAmiWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AmisAmiWithAfterDelete called before DefaultDeleteAmi in the default Delete handler
type AmisAmiWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteAmiResponse, *gorm1.DB) error
}

// List ...
func (m *AmisDefaultServer) List(ctx context.Context, in *ListAmiRequest) (*ListAmisResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AmisAmiWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListAmi(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListAmisResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(AmisAmiWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AmisAmiWithBeforeList called before DefaultListAmi in the default List handler
type AmisAmiWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AmisAmiWithAfterList called before DefaultListAmi in the default List handler
type AmisAmiWithAfterList interface {
	AfterList(context.Context, *ListAmisResponse, *gorm1.DB) error
}
